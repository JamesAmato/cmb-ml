# ml_cmb_pysm_sims
Rough development repository for PySM simulations for ML project

# Set Up

(This Section To Be Update)

Unfortunately, the current environment is a hodge-podge. I know that PySM3 had to be installed from the current version on GitHub, as the installation instructions produce a library without all the most recent components. "pip_" and "conda_packages.txt" contain current packages. I don't recall issues installing other packages.

# Needed files

"planck_assets/" files are needed for noise generation. There's a lot of data there (~2GB?). "fidu_noise/" files are only for comparisons of noise. WMAP 9 chains are not yet used. 

From [ESA Planck Page](https://pla.esac.esa.int/#results), choose Maps, then Advanced Search. Get the following:
- planck_assets/LFI_SkyMap_030-BPassCorrected_1024_R3.00_full.fits
- planck_assets/LFI_SkyMap_044-BPassCorrected_1024_R3.00_full.fits
- planck_assets/LFI_SkyMap_070-BPassCorrected_1024_R3.00_full.fits
- planck_assets/HFI_SkyMap_100_2048_R3.01_full.fits
- planck_assets/HFI_SkyMap_143_2048_R3.01_full.fits
- planck_assets/HFI_SkyMap_217_2048_R3.01_full.fits
- planck_assets/HFI_SkyMap_353-psb_2048_R3.01_full.fits
- planck_assets/HFI_SkyMap_545_2048_R3.01_full.fits
- planck_assets/HFI_SkyMap_857_2048_R3.01_full.fits
- fidu_noise/ffp10_noise_030_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_044_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_070_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_100_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_143_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_217_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_353_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_545_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_857_full_map_mc_00000.fits
- fidu_noise/ffp10_noise_353_psb_full_map_mc_00000.fits

From [NASA WMAP page](https://lambda.gsfc.nasa.gov/product/wmap/dr5/params/lcdm_wmap9.html), [Chain Files Direct Link](https://lambda.gsfc.nasa.gov/data/map/dr5/dcp/chains/wmap_lcdm_wmap9_chains_v5.tar.gz)

# Notes

Output is currently in K_RJ; I think it should be K_CMB. That's just the result of a bad guess I made early on and I'll correct it. The result is low signal at higher detector bands.

first_sim.py is just PySM3 without custom stuff.

fixed_map_synth1.py adds the CMB component ("Syn"). Currently I use CAMB to get a power spectrum. Currently, cosmological parameters are hard-coded. Later they will be drawn from WMAP9 Chains. Beam convolution is done poorly with a hard-coded beam fwhm roughly corresponding to the 100 GHz detector.

fixed_map_synth2.py adds beam convolutions which match values pulled from a PySM3 data table for the Planck Mission. Ideally, these would be pulled from Planck assets instead. That's a future update.

fixed_map_synth3.py adds noise. Noise is generated using official Planck observation maps. Those maps have the following fields
* TTYPE1  = 'I_STOKES'
* TTYPE2  = 'Q_STOKES'
* TTYPE3  = 'U_STOKES'
* TTYPE4  = 'HITS    '
* TTYPE5  = 'II_COV  '
* TTYPE6  = 'IQ_COV  '
* TTYPE7  = 'IU_COV  '
* TTYPE8  = 'QQ_COV  '
* TTYPE9  = 'QU_COV  '
* TTYPE10 = 'UU_COV  '

I use the II_COV, QQ_COV, and UU_COV fields, following the precedent set by Petroff. Those values are (if I understand correctly) the variance values per pixel for that field; it's covariance only in terms of the different I/Q/U, not how the pixels covary. I can draw random values using a Numpy RNG, which uses a scale parameter that's the standard deviation. Thus, I take the square root of the map values. I'm kinda out of my depth on that.

The noise in the polarization maps is extreme compared to the CMB signal. I checked that this is reasonable in two ways. The magnitude of CMB anisotropy in T is ~300 uK; for Q and U it's ~2.5 uK. Compare that to the variance maps: for instance, at 100 GHz the median T noise sd value is 44 uK (makes sense); Q is 68 uK; U is 67 uK. I also looked at the 2018 release noise simulations. In this case I think a good marker is the IQR. I see similar results: T: 59 uK, Q:89 uK, U:88 uK.

The comparison to variance results are generated by "inspect_planck_fits.py" and saved in "inspect_planck_results.txt". The comparison to noise simulations results are generated by "inspect_noise_fits.py" and saved in "inspect_noise_results.txt". 

# To do

* Figure out pip and conda installation steps
* Noise, CMB, and all components in a single map
* CMB component determined by cosmological parameter draws from WMAP 9 chains.
* Output, per component, default variation (requires 2 runs)
* Make presentation of the above
* Where not enough variation exists (read: same thing), use PySM component_objects interface instead of preset_strings 
* Move to Markov
* Traceability/reproducability (this is a lot of stuff, todo: break down further)
* Run simulations v1
* Clean up (better names for files, get rid of testing/learning one-offs)

Physics questions:
* Does this method work?
* Why do maps look weird (especially polarization) re: smoothing?
* Why do maps look weird (especially polarization) re: instrument noise?
* Are unit conversions correct?
* Is variance correct?
